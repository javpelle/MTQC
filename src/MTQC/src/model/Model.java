/**
 * This code is part of MTQC.
 * 
 * Copyright (c) 2020 Javier Pellejero, Luis Aguirre.
 * 
 * This code is licensed under the MIT License. You may obtain a copy 
 * of this license in the LICENSE file in the root directory of this source tree 
 * or at https://github.com/javpelle/MTQC/blob/master/LICENSE.
 */

package model;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import exception.EmptyListException;
import exception.NullStringException;
import exception.ShotsException;
import exception.TimeLimitException;
import javafx.util.Pair;
import model.language.Language;
import model.language.QSharp;
import model.language.Qiskit;
import model.language.Language.NotifyListener;
import model.mutant.Mutant;
import model.mutantoperator.MutantOperator;
import model.testing.ProbabilisticTesting;
import model.testing.QStateTesting;
import model.testing.Testing;
import model.testresult.TestResult;

/**
 * Model class for the MVC
 * 
 * @author Javier & Luis
 *
 */
public class Model implements Observable<Observer> {

	/**
	 * Observer.
	 */
	private Observer observer;

	/**
	 * Absolute path where the program is being executed.
	 */
	private String path;

	/**
	 * Relative path to temporally store all the mutants generated by the program.
	 */
	private static final String mutantPath = ".mutants";

	/**
	 * Conficende parameter.
	 */
	private double confidence;

	/**
	 * Used to store all the results gathered in the execution.
	 */
	private ArrayList<ArrayList<TestResult>> results;

	/**
	 * Initializes both type of test available.
	 */
	private Testing[] tests = { new QStateTesting(), new ProbabilisticTesting() };
	
	/**
	 * Initializes both type of language available.
	 */
	private Language[] languages = { new Qiskit(), new QSharp()	};

	/**
	 * Selected language.
	 */
	private Language selectedLanguage;

	/**
	 * Used to store all mutants generated by the program.
	 */
	private ArrayList<Mutant> mutantList;

	/**
	 * Empty constructor for the class.
	 * 
	 * @param language
	 */
	public Model() {
		confidence = 1.0;
		selectedLanguage = languages[0];
		mutantList = new ArrayList<Mutant>();
	}

	/**
	 * Notifies the observer that some error occurred, and throw an exception as
	 * well.
	 */
	public void notifyError(Exception e) {
		String msg = e.getLocalizedMessage();
		observer.onError(msg);
	}

	/**
	 * Notifies the observer that some error occurred.
	 */
	public void notifyError(String msg) {
		observer.onError(msg);
	}

	/**
	 * Notifies the observer that the language has changed.
	 */
	public void notifyLanguageChange() {
		observer.updateMutantOperators(selectedLanguage.getMutantOperators());
		observer.updateInputExample(selectedLanguage.getInputExample(null, 0, null));
	}

	@Override
	public void addObserver(Observer o) {
		observer = o;
	}

	@Override
	public void removeObserver(Observer o) {
		observer = null;
	}

	/**
	 * Starts the model.
	 */
	public void start() {
		updatePath(System.getProperty("user.dir"));
		notifyLanguageChange();
		observer.setTests(tests);
	}

	/**
	 * Resets the model to the initial state.
	 */
	public void reset() {
		removeMutants();
		mutantList = new ArrayList<Mutant>();
		start();
		observer.updateMutants(mutantList);
		observer.updateFileMethods(new ArrayList<String>(), mutantList);
	}

	/**
	 * Updates the mutants operators available for a language.
	 * 
	 * @param qiskit Indicates whether qiskit is selected or not.
	 */
	public void updateMutantOperators(int language) {
		selectedLanguage = languages[language];
		updatePath(path);
		notifyLanguageChange();
	}

	/**
	 * Updates to new path and notifies the UI
	 * 
	 * @param path New path.
	 */
	public void updatePath(String path) {
		this.path = path;
		ArrayList<String> files = new ArrayList<String>();
		File folder = new File(path);
		File[] listOfFiles = folder.listFiles();
		String extension = selectedLanguage.getExtension();
		for (int i = 0; i < listOfFiles.length; i++) {
			if (listOfFiles[i].isFile() && listOfFiles[i].getName().endsWith(extension)
					&& !listOfFiles[i].getName().startsWith("._")) {
				files.add(listOfFiles[i].getName());
			}
		}
		observer.updatePath(files);
		observer.notifyMutantsGenerator("Ruta actual: " + path + "\n");
	}

	/**
	 * Aplies all posible mutant operations to a set of files.
	 * 
	 * @param files     Set of files.
	 * @param operators Mutant operators wanted to be aplied.
	 */
	public void generate(ArrayList<String> files, ArrayList<MutantOperator> operators) {
		try {
			if (files.isEmpty()) {
				observer.notifyMutantsGenerator("No files selected!\n");
				throw new EmptyListException("File list");
			} else if (operators.isEmpty()) {
				observer.notifyMutantsGenerator("No operators selected!\n");
				throw new EmptyListException("Operator list");
			} else {
				File file = new File(mutantPath);
				file.mkdir();
				for (int i = 0; i < files.size(); i++) {
					for (int j = 0; j < operators.size(); j++) {
						mutantList.addAll(applyOperatorToFile(files.get(i), operators.get(j)));
					}
				}
				observer.notifyMutantsGenerator(
						"Completed. " + String.valueOf(mutantList.size()) + " mutants generated!\n");
				observer.updateMutants(mutantList);
			}
		} catch (EmptyListException e) {
			notifyError(e);
		}
	}

	/**
	 * Aplies a particular mutant operator to a particular file. We only aply 1
	 * operator at a time.
	 * 
	 * @param filePath       Name of the file.
	 * @param mutantOperator Mutant operator to be aplied.
	 * @return
	 */
	private ArrayList<Mutant> applyOperatorToFile(String filePath, MutantOperator mutantOperator) {
		ArrayList<Mutant> auxList = new ArrayList<Mutant>();
		String searchWord = mutantOperator.getSearchOperator();
		String replaceWord = mutantOperator.getMutantOperator();
		String completeFilePath = path + File.separator + filePath;
		File originalFile = new File(completeFilePath);
		String file = "";
		BufferedReader reader = null;
		ArrayList<Pair<Integer, Integer>> lineOffset = new ArrayList<Pair<Integer, Integer>>();
		int lineCount = 1;
		int totalOffset = 0;

		try {
			reader = new BufferedReader(new FileReader(originalFile));
			String line = reader.readLine();

			while (line != null) {
				line = " " + line;
				for (int offset = 1; offset < line.length(); offset++) {
					if (line.startsWith(searchWord, offset)
							&& selectedLanguage.verifyMatch(mutantOperator, line, offset, searchWord)) {
						lineOffset.add(new Pair<Integer, Integer>(lineCount, totalOffset + offset - 1));
					}
				}

				file = file + line.substring(1) + System.lineSeparator();
				totalOffset = file.length();
				lineCount++;
				line = reader.readLine();
			}

			StringBuilder fileBuilder = new StringBuilder(file);
			File saveFile;
			BufferedWriter writer = null;
			for (int i = 0; i < lineOffset.size(); i++) {

				fileBuilder.delete(lineOffset.get(i).getValue(), lineOffset.get(i).getValue() + searchWord.length());
				fileBuilder.insert(lineOffset.get(i).getValue(), replaceWord);
				String name = "_" + Integer.toString(i) + "_" + mutantOperator.getName() + "_" + filePath;
				String filePathWrite = mutantPath + File.separator + name;
				saveFile = new File(filePathWrite);
				try {
					writer = new BufferedWriter(new FileWriter(saveFile));
					writer.write(fileBuilder.toString());
				} finally {
					if (writer != null)
						writer.close();
				}
				auxList.add(new Mutant(name, path, filePath, mutantPath, name, lineOffset.get(i).getKey()));

				// Devolvemos la estructura general de fileBuilder.

				fileBuilder.delete(lineOffset.get(i).getValue(), lineOffset.get(i).getValue() + replaceWord.length());
				fileBuilder.insert(lineOffset.get(i).getValue(), searchWord);
			}
		} catch (

		IOException e) {
			notifyError(e);
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				notifyError(e);
				e.printStackTrace();
			}
		}
		return auxList;
	}

	/**
	 * Deletes the files generated during mutation process.
	 */
	public void removeMutants() {
		for (Mutant m : mutantList) {
			try {
				File f = new File(m.getMutantCompletePath()); // file to be delete
				f.delete();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Updates the path to check new files.
	 */
	public void refreshPath() {
		updatePath(path);
	}

	/**
	 * Gets the name of all methods in a file.
	 * 
	 * @param fileName Name of the file where it search for methods.
	 */
	public void getFileMethods(String fileName) {
		String startMethodToken = selectedLanguage.getStartMethodToken();
		String endMethodToken = selectedLanguage.getEndMethodToken();

		ArrayList<String> fileMethods = new ArrayList<String>();

		String completeFilePath = path + File.separator + fileName;
		File file = new File(completeFilePath);
		BufferedReader reader = null;
		String fileString = "";

		try {
			reader = new BufferedReader(new FileReader(file));
			String line = reader.readLine();
			while (line != null) {
				fileString = fileString + line + System.lineSeparator();
				line = reader.readLine();
			}

			int indexStart = fileString.indexOf(startMethodToken, 0);
			int indexEnd;
			while (indexStart != -1) {

				indexEnd = fileString.indexOf(endMethodToken, indexStart + startMethodToken.length());
				fileMethods.add(fileString.substring(indexStart + startMethodToken.length(), indexEnd));
				indexStart = fileString.indexOf(startMethodToken, indexEnd + endMethodToken.length());

			}

		} catch (IOException e) {
			notifyError(e);
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				notifyError(e);
				e.printStackTrace();
			}
		}
		ArrayList<Mutant> aux = new ArrayList<Mutant>();
		for (Mutant m : mutantList) {
			if (m.getOriginalName().equals(fileName)) {
				aux.add(m);
			}
		}
		observer.updateFileMethods(fileMethods, aux);

	}

	/**
	 * Updates the confidence parameter, and revalues which mutants die.
	 * 
	 * @param confidence New value for confidence parameter.
	 */
	public void updateConfidence(double confidence) {
		this.confidence = confidence;
		if (results != null) {
			getKills();
		}
	}

	/**
	 * Given a mutant list and a set of test, runs all possible combinations of
	 * test/mutant.
	 * 
	 * @param mutantList List of mutants.
	 * @param testSuit   List of test.
	 * @param test       Type of test to be applied.
	 * @param file       Name of the original file.
	 * @param method     Name of the method being tested.
	 * @param timeLimit  Maximum time each test can run for.
	 */
	public void run(ArrayList<Mutant> mutantList, ArrayList<String> testSuit, Testing test, String file, String method,
			double timeLimit) {
		try {
			if (timeLimit <= 0) {
				throw new TimeLimitException();
			}
			if (test.getShots() <= 0) {
				throw new ShotsException();
			}
			if (testSuit.size() == 0) {
				throw new EmptyListException("Test list");
			}
			if (file == null || file.equals("")) {
				throw new NullStringException("file");
			}
			if (method == null || file.equals("")) {
				throw new NullStringException("method");
			}
			if (mutantList.size() == 0) {
				throw new EmptyListException("Mutant list");
			}

			NotifyListener listener = new NotifyListener() {
				@Override
				public void notify(String msg) {
					observer.notifyTestCaseRunner(msg);
				}
			};
			results = selectedLanguage.run(mutantList, testSuit, test, method, timeLimit, listener);

			observer.notifyResults(results);
			getKills();
			observer.notifyTestCaseRunner("Completed\n");
		} catch (TimeLimitException | ShotsException | EmptyListException | NullStringException e) {
			notifyError(e);
		} catch (Exception e) {
			notifyError("Unknown error occurred during execution. Please, check your test and try again.");
		}
	}

	/**
	 * Calculates which mutant dies and which live.
	 */
	private void getKills() {
		ArrayList<ArrayList<Boolean>> kills = new ArrayList<ArrayList<Boolean>>();
		for (ArrayList<TestResult> list : results) {
			ArrayList<Boolean> aux = new ArrayList<Boolean>();
			for (int i = 1; i < list.size(); i++) {
				aux.add(list.get(i).getKill(list.get(0), confidence));
			}
			kills.add(aux);
		}

		observer.updateKills(kills);
	}

	public void updateTesting(Testing testing, int shots, String methodName) {
		observer.updateInputExample(selectedLanguage.getInputExample(testing, shots, methodName));		
	}

}
